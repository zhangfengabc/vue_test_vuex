//规则归类

// #优先级A:必要的

// #优先级B:强烈推荐

// #优先级C: 推荐

// #优先级D: 谨慎使用


///////////////////////////////////////
//#优先级A的规则 : 必要的（规避错误）

//#组件名为多个单词

//#组件的data 必须是一个函数

//#Prop定义应该尽量详细，至少需要指定其类型。
//反例 
props: ['status']

//好例子
props: {
    status: String
}
//更好的做法！
props: {
    status: {
        type: String,
        required: true,
        validator: function (value) {
            return [
                'syncing',
                'error'
            ].indexOf(value) !== -1
        }
    }
}

//#为v-for设置键值，  总是用key配合v-for

//避免 v-if 和 v-for 用在一起
//永远不要把v-if 和 v-for同时用在同一个元素上。


//#为组件样式设置作用域



//私有property名



//优先级B的规则：强烈推荐（增强可读性）

//#组件文件
//只要有能够拼接文件的构建系统，就把每个组件单独分成文件


//#但文件组件文件的大小写
//单文件组件的文件名要么始终是单词大写开头（PascalCase）,要么始终是横线链接（kebab-case）



//#基础组件名
//应用特定样式和约定的基础组件（也就是展示类的、无逻辑的或五状态的组件）应该全部以一个特定的前缀开头，比如Base、App 或 v/

//好例子
// BaseButton.vue  BaseTable.vue   BaseIcon.vue
// AppButton.vue  AppTable.vue   AIcon.vue
// VButton.vue  VTable.vue   VIcon.vue



//#单例组件名
//只应该拥有单个活跃实例的组件应该以  The 前缀命名，以示其唯一性。

//这不意味着组件只可用于一个单页面，而是每个页面只使用一次。这些组件不用不接受任何prop,因为它们是为你的应用定制的，
//而不是它们在你得应用中的上下文。如果你发现有必要添加prop,那就表面这实际上是一个可复用的组件，只是目前在每个页面只使用一次。





//#紧密耦合的组件名
//和父组件紧密耦合的子组件应该以父组件名作为前缀命名。


//#组件名中的单词顺序
//组件名应该以高级别的（通常是一般化描述的）单词开头，以描述性的修饰词结尾。



//#自闭合组件



//#完整单词的组件名
//组件名应该倾向于完整单词而不是缩写。



//#Prop名大小写
//在声明prop的时候，其命名应该始终使用camelCase，而在模板和JSX中应该始终使用kebab-case 。






//#多个attribute的元素
//多个attribute 的元素应该分多行撰写，每个attribute一行。



//#模板中的简单表达式
//组件模板应该只包含简单的表达式，赋值的表达式则应该重构为计算属性或方法。




//#简单的计算属性
//应该把复杂计算属性分割为尽可能多的更简单的property



//带引号的attribute值
//非空HTML attribute 值应该始终带引号（单引号或双引号，选你js里不用的那个）




//#指令缩写
//指令缩写（用 ：表示 v-bind: 、 用 @ 表示 v-on: 、 和用 # 表示 v-slot:）应该要么都用要么都不用。


//-------------------------------
//优先级C的规则：推荐（将选择和认知成本最小化）


//#组件/实例的选项的顺序
//组件/实例的选项应该有统一的顺序




//#元素attribute的顺序
//元素（包括组件）的attribute应该有统一的顺序








//#组件/实例选项中的空行



//#单文件组件的顶级元素的顺序






//----------------------------

//#优先级D的规则： 谨慎使用（有潜在危险的模式）




//# 没有在 v-if / v-else-if / v-else 中使用 key


//#scoped 中的元素选择器
//元素选择器应该避免在scoped中出现
//在scoped样式中，类选择器不元素选择器更好，因为大量使用元素选择器是很慢的。





//#隐形的父子组件通信
//应该优先通过和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。






//#非Flux的全局状态管理
//应该优先通过Vuex管理全局状态，而不是通过this.$root或一个全局事件总线。








